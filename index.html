onValue(slotsRef, (snapshot) => {
  const data = snapshot.val();
  let availableCount = 0;

  for (let key in data) {
    const slotElement = document.getElementById(key);

    // Use the value directly (string: "filled" / "empty")
    const status = data[key]; 

    if (status === "empty") {
      slotElement.style.background = "#2ecc71"; // green
      slotElement.innerHTML = key.toUpperCase() + " - <span class='badge empty'>EMPTY</span>";
      availableCount++;
    } else if (status === "filled") {
      slotElement.style.background = "#e74c3c"; // red
      slotElement.innerHTML = key.toUpperCase() + " - <span class='badge filled'>FILLED</span>";
    }

    // Track changes to record entry/exit
    if (!lastStatus[key]) lastStatus[key] = status;

    // Entry detected
    if (status === "filled" && lastStatus[key] === "empty") {
      const now = new Date().toLocaleTimeString();
      set(ref(database, `slots/${key}/entry`), now);

      // Add to history
      const newRecord = push(historyRef);
      set(newRecord, {
        slot: key,
        entry: now,
        exit: "",
        duration: ""
      });
    }

    // Exit detected
    if (status === "empty" && lastStatus[key] === "filled") {
      const now = new Date().toLocaleTimeString();
      set(ref(database, `slots/${key}/exit`), now);

      // Update latest history record
      onValue(historyRef, (historySnap) => {
        const historyData = historySnap.val();
        if (historyData) {
          const keys = Object.keys(historyData).reverse();
          for (let k of keys) {
            if (historyData[k].slot === key && historyData[k].exit === "") {
              const entryTime = new Date("1970/01/01 " + historyData[k].entry);
              const exitTime = new Date("1970/01/01 " + now);
              const diff = Math.floor((exitTime - entryTime)/60000); // minutes
              set(ref(database, `history/${k}/exit`), now);
              set(ref(database, `history/${k}/duration`), diff + " mins");
              break;
            }
          }
        }
      }, { onlyOnce: true });
    }

    lastStatus[key] = status;
  }

  // Update UI
  document.getElementById("available").innerText = "Available: " + availableCount;
  document.getElementById("updated").innerText = "Last Update: " + new Date().toLocaleTimeString();

  // Update history table
  onValue(historyRef, (historySnap) => {
    const historyData = historySnap.val();
    const tbody = document.getElementById("historyTable");
    tbody.innerHTML = "";
    if (historyData) {
      const keys = Object.keys(historyData).reverse();
      for (let k of keys) {
        const record = historyData[k];
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${record.slot}</td>
          <td>${record.entry || "--"}</td>
          <td>${record.exit || "--"}</td>
          <td>${record.duration || "--"}</td>
        `;
        tbody.appendChild(tr);
      }
    }
  }, { onlyOnce: false });
});
