let lastStatus = {};

onValue(slotsRef, (snapshot) => {
  const data = snapshot.val();
  let availableCount = 0;

  for (let key in data) {
    const slotElement = document.getElementById(key);
    const status = data[key]; // direct string from ESP32

    // Update slot card UI
    if (status === "empty") {
      slotElement.style.background = "#2ecc71";
      slotElement.innerHTML = key.toUpperCase() + " - <span class='badge empty'>EMPTY</span>";
      availableCount++;
    } else if (status === "filled") {
      slotElement.style.background = "#e74c3c";
      slotElement.innerHTML = key.toUpperCase() + " - <span class='badge filled'>FILLED</span>";
    }

    // Initialize lastStatus if undefined
    if (!(key in lastStatus)) lastStatus[key] = status;

    // Entry detected
    if (status === "filled" && lastStatus[key] === "empty") {
      const now = new Date().toLocaleTimeString();
      set(ref(database, `slots/${key}/entry`), now);

      const newRecord = push(historyRef);
      set(newRecord, {
        slot: key,
        entry: now,
        exit: "",
        duration: ""
      });
    }

    // Exit detected
    if (status === "empty" && lastStatus[key] === "filled") {
      const now = new Date().toLocaleTimeString();
      set(ref(database, `slots/${key}/exit`), now);

      // Update latest history record for this slot
      onValue(historyRef, (historySnap) => {
        const historyData = historySnap.val();
        if (historyData) {
          const keys = Object.keys(historyData).reverse();
          for (let k of keys) {
            if (historyData[k].slot === key && historyData[k].exit === "") {
              const entryTime = new Date("1970/01/01 " + historyData[k].entry);
              const exitTime = new Date("1970/01/01 " + now);
              const diff = Math.floor((exitTime - entryTime) / 60000);
              set(ref(database, `history/${k}/exit`), now);
              set(ref(database, `history/${k}/duration`), diff + " mins");
              break;
            }
          }
        }
      }, { onlyOnce: true });
    }

    // Update lastStatus at the end
    lastStatus[key] = status;
  }

  // Update available slots and last update time
  document.getElementById("available").innerText = "Available: " + availableCount;
  document.getElementById("updated").innerText = "Last Update: " + new Date().toLocaleTimeString();

  // Update history table
  onValue(historyRef, (historySnap) => {
    const historyData = historySnap.val();
    const tbody = document.getElementById("historyTable");
    tbody.innerHTML = "";
    if (historyData) {
      const keys = Object.keys(historyData).reverse();
      for (let k of keys) {
        const record = historyData[k];
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${record.slot}</td>
          <td>${record.entry || "--"}</td>
          <td>${record.exit || "--"}</td>
          <td>${record.duration || "--"}</td>
        `;
        tbody.appendChild(tr);
      }
    }
  }, { onlyOnce: false });
});
